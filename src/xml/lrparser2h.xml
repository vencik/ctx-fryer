<?xml version="1.0"?>
<!DOCTYPE xsl:stylesheet [
<!ENTITY dquote "&#34;">
<!ENTITY quote  "&#39;">
<!ENTITY dots   "&#133;">
<!ENTITY dollar "&#36;">
<!ENTITY eol    "&#10;">
]>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns:ctx-fryer="ctx-fryer"
                xmlns:math="math"
                version="1.0">

<xsl:output method="text" encoding="ISO-8859-1" />
<xsl:strip-space elements="*" />

<!-- Pad string with spaces (from right) to defined length -->
<xsl:template name="pad-string">
  <xsl:param name="string"   data-type="string" />
  <xsl:param name="length"   data-type="number" />
  <xsl:param name="pad-at"   data-type="string" select="'left'" />
  <xsl:param name="pad-char" data-type="string" select="' '" />
  <xsl:variable name="to-go" data-type="number" select="$length - string-length($string)" />
  <xsl:choose>
    <xsl:when test="$to-go &lt;= 0">
      <xsl:value-of select="$string" />
    </xsl:when>
    <xsl:otherwise>
      <xsl:variable name="padded-string">
        <xsl:choose>
          <xsl:when test="$pad-at = 'left'">
            <xsl:value-of select="concat($pad-char, $string)" />
          </xsl:when>
          <xsl:when test="$pad-at = 'right'">
            <xsl:value-of select="concat($string, $pad-char)" />
          </xsl:when>
          <xsl:otherwise>
            <!-- LOGICAL ERROR (but how can it be propagated?) -->
            <xsl:value-of select="'INTERNAL ERROR'" />
          </xsl:otherwise>
        </xsl:choose>
      </xsl:variable>
      <xsl:call-template name="pad-string">
        <xsl:with-param name="string"   select="$padded-string" />
        <xsl:with-param name="length"   select="$length" />
        <xsl:with-param name="pad-at"   select="$pad-at" />
        <xsl:with-param name="pad-char" select="$pad-char" />
      </xsl:call-template>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>


<!-- Maximal node text string length -->
<xsl:template name="max-string-length">
  <xsl:param name="nodes" />
  <xsl:param name="min" data-type="number" select="0" />
  <xsl:choose>
    <xsl:when test="count($nodes) = 0">
      <xsl:value-of select="$min" />
    </xsl:when>
    <xsl:when test="count($nodes) = 1">
      <xsl:value-of select="string-length(string($nodes[position() = 1]))" />
    </xsl:when>
    <xsl:otherwise>
      <xsl:variable name="even-maxlen">
        <xsl:call-template name="max-string-length">
          <xsl:with-param name="nodes" select="$nodes[position() mod 2 = 0]" />
        </xsl:call-template>
      </xsl:variable>
      <xsl:variable name="odd-maxlen">
        <xsl:call-template name="max-string-length">
          <xsl:with-param name="nodes" select="$nodes[position() mod 2 != 0]" />
        </xsl:call-template>
      </xsl:variable>
      <xsl:choose>
        <xsl:when test="$even-maxlen &gt; $odd-maxlen">
          <xsl:value-of select="$even-maxlen" />
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="$odd-maxlen" />
        </xsl:otherwise>
      </xsl:choose>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>


<xsl:variable name="root-id"    select="/lr-parser/grammar/@root-non-terminal-id" />
<xsl:variable name="root-ident" select="/lr-parser/grammar/non-terminals/list/list-item/non-terminal-symbol[@id = $root-id]/@identifier" />

<xsl:variable name="non-terminals"              select="/lr-parser/grammar/non-terminals/list/list-item/non-terminal-symbol" />
<xsl:variable name="non-terminals-noroot"       select="$non-terminals[not(@id = $root-id)]" />
<xsl:variable name="non-terminal-noroot-cnt"    select="count($non-terminals-noroot)" data-type="number" />
<xsl:variable name="non-terminal-noroot-maxnum" select="$non-terminal-noroot-cnt - 1" data-type="number" />

<xsl:variable name="non-terminal-noroot-maxlen" data-type="number">
  <xsl:call-template name="max-string-length">
    <xsl:with-param name="nodes" select="$non-terminals-noroot/@identifier" />
  </xsl:call-template>
</xsl:variable>

<xsl:variable name="non-terminal-noroot-number-maxlen" data-type="number" select="string-length($non-terminal-noroot-maxnum)" />


<!-- Grammar non-terminals enumenration generation -->
<xsl:template match="lr-parser">#ifndef nonterminals_h
#define nonterminals_h

/**
 *  \brief  Grammar non-terminals enumeration
 *
 *  The code is generated; do NOT change it, manually.
 *
 *  This file is part of code generated by CTXFryer
 *  while producing syntax analyser source code.
 *
 *  \date  2012/08/24
 */


<!-- Enumerate non-terminals except the augemnted grammar root -->
<xsl:for-each select="$non-terminals-noroot">
  <xsl:sort select="@id" />
  <xsl:text>#define NT_</xsl:text>
  <xsl:call-template name="pad-string">
    <xsl:with-param name="string" select="@identifier" />
    <xsl:with-param name="length" select="$non-terminal-noroot-maxlen" />
    <xsl:with-param name="pad-at" select="'right'" />
  </xsl:call-template>
  <xsl:text> </xsl:text>
  <xsl:call-template name="pad-string">
    <xsl:with-param name="string" select="position() - 1" />
    <xsl:with-param name="length" select="$non-terminal-noroot-number-maxlen" />
    <xsl:with-param name="pad-at" select="'left'" />
  </xsl:call-template>
  <xsl:text>  /**&lt; ID </xsl:text>
  <xsl:value-of select="@id" />
  <xsl:text> */&eol;</xsl:text>
</xsl:for-each>

<!-- Making sure that the augmented grammar root has the greatest number -->
<xsl:text>&eol;/** Augmented grammar root, ID </xsl:text>
<xsl:value-of select="$root-id" />
<xsl:text> */&eol;</xsl:text>
<xsl:text>#define NT_</xsl:text>
<xsl:value-of select="$root-ident" />
<xsl:text> </xsl:text>
<xsl:value-of select="$non-terminal-noroot-cnt" />

#endif  /* end of #ifndef nonterminals_h */
</xsl:template>

</xsl:stylesheet>
